"""Configuration models for Revis."""

from pathlib import Path
from typing import Literal

import yaml
from pydantic import BaseModel, field_validator


class ExecutorConfig(BaseModel):
    """Configuration for the executor."""

    type: Literal["local", "ssh"] = "local"
    host: str | None = None
    user: str | None = None
    port: int = 22
    key_path: str | None = None
    work_dir: str = "."

    @field_validator("host", "user")
    @classmethod
    def validate_ssh_fields(cls, v, info):
        return v

    def model_post_init(self, __context):
        if self.type == "ssh":
            if not self.host:
                raise ValueError("executor.host is required when type is 'ssh'")
            if not self.user:
                raise ValueError("executor.user is required when type is 'ssh'")


class EntryConfig(BaseModel):
    """Entry point configuration.

    Revis injects REVIS_OUTPUT_DIR environment variable when running training.
    Your training script should write eval.json and any artifacts there.
    """

    train: str
    eval: str | None = None  # Optional separate eval command
    env: dict[str, str] = {}  # Additional env vars to set
    env_passthrough: list[str] = []  # Env var names to pass from current environment


class MetricsConfig(BaseModel):
    """Metrics configuration."""

    source: Literal["wandb", "mlflow", "tensorboard", "eval_json"] = "eval_json"
    project: str | None = None  # W&B/MLFlow project name
    entity: str | None = None  # W&B entity (username or team)
    primary: str
    minimize: bool = True
    target: float | None = None


class CodingAgentConfig(BaseModel):
    """Coding agent configuration for code change handoffs."""

    type: Literal["auto", "claude-code", "none"] = "auto"
    auto_handoff: bool = True  # false = pause and ask before handing off
    verify: bool = True  # run smoke test after changes


class GuardrailsConfig(BaseModel):
    """Guardrails configuration."""

    plateau_threshold: float = 0.01
    plateau_runs: int = 3
    max_run_duration: str = "24h"
    retry_budget: int = 3
    divergence_multiplier: float = 10.0

    nan_detection_enabled: bool = True
    divergence_detection_enabled: bool = True
    plateau_detection_enabled: bool = True
    timeout_enabled: bool = True

    @field_validator("max_run_duration")
    @classmethod
    def validate_duration(cls, v: str) -> str:
        parse_duration(v)
        return v


class ContextConfig(BaseModel):
    """Context configuration for LLM agent."""

    deny: list[str] = []  # Patterns to block from reading AND writing
    constraints: list[str] = []  # Free-text constraints for the LLM
    history: int = 10
    log_tail_lines: int = 200
    max_agent_iterations: int = 20


class LLMConfig(BaseModel):
    """LLM configuration."""

    model: str = "claude-sonnet-4-20250514"
    api_base: str | None = None
    fallback: list[str] = []


class ArtifactsConfig(BaseModel):
    """Artifact storage configuration."""

    path: str = ".revis/artifacts"


class AutoMergeConfig(BaseModel):
    """Auto-merge configuration."""

    enabled: bool = False
    require_target_achieved: bool = True
    min_improvement_percent: float | None = None


class GitHubConfig(BaseModel):
    """GitHub configuration."""

    auto_merge: AutoMergeConfig = AutoMergeConfig()


class RevisConfig(BaseModel):
    """Main Revis configuration."""

    executor: ExecutorConfig
    entry: EntryConfig
    metrics: MetricsConfig
    guardrails: GuardrailsConfig = GuardrailsConfig()
    context: ContextConfig = ContextConfig()
    llm: LLMConfig = LLMConfig()
    artifacts: ArtifactsConfig = ArtifactsConfig()
    github: GitHubConfig = GitHubConfig()
    coding_agent: CodingAgentConfig = CodingAgentConfig()


def parse_duration(duration_str: str) -> int:
    """Parse duration string to seconds. Supports: 30s, 5m, 2h, 1d."""
    duration_str = duration_str.strip().lower()
    if not duration_str:
        raise ValueError("Empty duration string")

    multipliers = {"s": 1, "m": 60, "h": 3600, "d": 86400}
    unit = duration_str[-1]

    if unit not in multipliers:
        raise ValueError(f"Invalid duration unit: {unit}. Use s, m, h, or d.")

    try:
        value = int(duration_str[:-1])
    except ValueError:
        raise ValueError(f"Invalid duration value: {duration_str[:-1]}")

    return value * multipliers[unit]


def load_config(path: Path) -> RevisConfig:
    """Load configuration from YAML file."""
    with open(path) as f:
        data = yaml.safe_load(f)
    return RevisConfig(**data)


def get_config_template() -> str:
    """Get the default configuration template."""
    return """# Revis Configuration
# Generated by 'revis init'. Edit as needed.

executor:
  type: local  # 'local' (run here) or 'ssh' (sync to remote)
  work_dir: .
  # SSH settings (only if type: ssh)
  # host: your-gpu-server.example.com
  # user: your-username
  # port: 22

entry:
  train: "python train.py"

metrics:
  source: eval_json  # wandb, mlflow, tensorboard, or eval_json
  # project: my-project  # W&B/MLFlow project (if using)
  # entity: my-entity  # W&B entity (if using)
  primary: loss
  minimize: true
  # target: 0.1  # Optional early stopping target

guardrails:
  plateau_threshold: 0.01
  plateau_runs: 3
  max_run_duration: 24h
  retry_budget: 3

context:
  deny:
    - ".git/**"
    - "**/__pycache__/**"
    - "*.pt"
    - "*.ckpt"
    - "*.safetensors"
    - "wandb/**"
    - ".revis/**"
    - "revis.yaml"
  constraints:  # Natural language constraints for the LLM
    # - "Learning rate must be between 1e-6 and 1e-2"
    # - "Batch size must be a power of 2"
  history: 10
  log_tail_lines: 200
  max_agent_iterations: 20

llm:
  # Uncomment one of the models below (requires corresponding API key in env)
  # See https://docs.litellm.ai/docs/providers for full list of supported models
  #
  # Anthropic (ANTHROPIC_API_KEY)
  # model: claude-sonnet-4-20250514
  # model: claude-opus-4-5-20251101
  # model: claude-haiku-4-5-20251001
  #
  # OpenAI (OPENAI_API_KEY)
  # model: gpt-5.2-2025-12-11
  # model: gpt-5-mini-2025-08-07
  # model: gpt-5-nano-2025-08-07
  #
  # Google (GEMINI_API_KEY)
  # model: gemini/gemini-3-pro-preview
  # model: gemini/gemini-3-flash-preview
  # model: gemini/gemini-2.5-flash
  #
  model: claude-sonnet-4-5-20250929  # default

coding_agent:
  type: auto  # auto, claude-code, or none
  auto_handoff: true  # false = pause and ask before handing off
  verify: true  # run smoke test after code changes

artifacts:
  path: .revis/artifacts

github:
  auto_merge:
    enabled: false
    require_target_achieved: true
"""


def generate_config_yaml(
    train_command: str,
    metrics_source: str,
    metrics_project: str | None,
    metrics_entity: str | None,
    primary_metric: str,
    minimize: bool,
    executor_type: str,
    ssh_host: str | None = None,
    ssh_user: str | None = None,
    ssh_port: int = 22,
    ssh_key_path: str | None = None,
    coding_agent_type: str = "auto",
) -> str:
    """Generate revis.yaml content from interactive init results."""
    lines = ["# Revis Configuration", ""]

    # Executor section
    lines.append("executor:")
    lines.append(f"  type: {executor_type}")
    if executor_type == "ssh":
        lines.append(f"  host: {ssh_host}")
        lines.append(f"  user: {ssh_user}")
        lines.append(f"  port: {ssh_port}")
        if ssh_key_path:
            lines.append(f"  key_path: {ssh_key_path}")
        lines.append("  work_dir: ~/revis-work")
    else:
        lines.append("  work_dir: .")
    lines.append("")

    # Entry section
    lines.append("entry:")
    lines.append(f'  train: "{train_command}"')
    lines.append("")

    # Metrics section
    lines.append("metrics:")
    lines.append(f"  source: {metrics_source}")
    if metrics_project:
        lines.append(f"  project: {metrics_project}")
    if metrics_entity:
        lines.append(f"  entity: {metrics_entity}")
    lines.append(f"  primary: {primary_metric}")
    lines.append(f"  minimize: {str(minimize).lower()}")
    lines.append("")

    # Guardrails
    lines.append("guardrails:")
    lines.append("  plateau_threshold: 0.01")
    lines.append("  plateau_runs: 3")
    lines.append("  max_run_duration: 24h")
    lines.append("  retry_budget: 3")
    lines.append("")

    # Context
    lines.append("context:")
    lines.append("  deny:")
    lines.append('    - ".git/**"')
    lines.append('    - "**/__pycache__/**"')
    lines.append('    - "*.pt"')
    lines.append('    - "*.ckpt"')
    lines.append('    - "*.safetensors"')
    lines.append('    - "wandb/**"')
    lines.append('    - ".revis/**"')
    lines.append('    - "revis.yaml"')
    lines.append("  constraints:  # Natural language constraints for the LLM")
    lines.append('    # - "Learning rate must be between 1e-6 and 1e-2"')
    lines.append('    # - "Batch size must be a power of 2"')
    lines.append("  history: 10")
    lines.append("  log_tail_lines: 200")
    lines.append("  max_agent_iterations: 20")
    lines.append("")

    # LLM
    lines.append("llm:")
    lines.append("  # Uncomment one of the models below (requires corresponding API key in env)")
    lines.append("  # See https://docs.litellm.ai/docs/providers for full list of supported models")
    lines.append("  #")
    lines.append("  # Anthropic (ANTHROPIC_API_KEY)")
    lines.append("  # model: claude-sonnet-4-20250514")
    lines.append("  # model: claude-opus-4-5-20251101")
    lines.append("  # model: claude-haiku-4-5-20251001")
    lines.append("  #")
    lines.append("  # OpenAI (OPENAI_API_KEY)")
    lines.append("  # model: gpt-5.2-2025-12-11")
    lines.append("  # model: gpt-5-mini-2025-08-07")
    lines.append("  # model: gpt-5-nano-2025-08-07")
    lines.append("  #")
    lines.append("  # Google (GEMINI_API_KEY)")
    lines.append("  # model: gemini/gemini-3-pro-preview")
    lines.append("  # model: gemini/gemini-3-flash-preview")
    lines.append("  # model: gemini/gemini-2.5-flash")
    lines.append("  #")
    lines.append("  model: claude-sonnet-4-5-20250929  # default")
    lines.append("")

    # Coding agent
    lines.append("coding_agent:")
    lines.append(f"  type: {coding_agent_type}")
    lines.append("  auto_handoff: true")
    lines.append("  verify: true")
    lines.append("")

    # Artifacts
    lines.append("artifacts:")
    lines.append("  path: .revis/artifacts")
    lines.append("")

    # GitHub
    lines.append("github:")
    lines.append("  auto_merge:")
    lines.append("    enabled: false")
    lines.append("    require_target_achieved: true")

    return "\n".join(lines)
